from concurrent.futures import Future
from fractions import Fraction
from typing import (
    IO,
    Any,
    Callable,
    Final,
    Iterator,
    Literal,
    Self,
    TypeAlias,
    overload,
)
from warnings import deprecated

from ._typing import _SupportsInt, _VSValue
from .constants import FilterMode, MessageType, SampleType, VapourSynthAPIVersion, VapourSynthVersion
from .formats import ChannelLayout, VideoFormat
from .frames import AudioFrame, RawFrame, VideoFrame
from .logging import LogHandle
from .plugin import Plugin

class RawNode:
    @overload
    def get_frame_async(self, n: int) -> Future[RawFrame]: ...
    @overload
    def get_frame_async(self, n: int, cb: Callable[[RawFrame | None, Exception | None], None]) -> None: ...
    def frames(
        self, prefetch: int | None = None, backlog: int | None = None, close: bool = False
    ) -> Iterator[RawFrame]: ...
    def clear_cache(self) -> None: ...
    def is_inspectable(self, version: int | None = None) -> bool: ...
    @property
    def node_name(self) -> str: ...
    @property
    def timings(self) -> int: ...
    @timings.setter
    def timings(self, value: Literal[0]) -> None: ...
    @property
    def mode(self) -> FilterMode: ...
    @property
    def dependencies(self) -> tuple[Self, ...]: ...
    @property
    def _name(self) -> str: ...
    @property
    def _inputs(self) -> dict[str, _VSValue]: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

_CurrentFrame: TypeAlias = int
_TotalFrames: TypeAlias = int

# Behave like a Sequence
class VideoNode(RawNode):
    format: Final[VideoFormat]
    width: Final[int]
    height: Final[int]
    num_frames: Final[int]
    fps_num: Final[int]
    fps_den: Final[int]
    fps: Final[Fraction]
    @overload  # type: ignore[override]
    def get_frame_async(self, n: int) -> Future[VideoFrame]: ...
    @overload
    def get_frame_async(self, n: int, cb: Callable[[VideoFrame | None, Exception | None], None]) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def frames(
        self, prefetch: int | None = None, backlog: int | None = None, close: bool = False
    ) -> Iterator[VideoFrame]: ...
    def __getattr__(self, name: str) -> Plugin: ...
    def get_frame(self, n: int) -> VideoFrame: ...
    def set_output(self, index: int = 0, alpha: Self | None = None, alt_output: Literal[0, 1, 2] = 0) -> None: ...
    def output(
        self,
        fileobj: IO[bytes],
        y4m: bool = False,
        progress_update: Callable[[_CurrentFrame, _TotalFrames], None] | None = None,
        prefetch: int = 0,
        backlog: int = -1,
    ) -> None: ...
    def __add__(x, y: Self) -> Self: ...  # pyright: ignore[reportSelfClsParameterName]
    def __mul__(a, b: Self) -> Self: ...  # pyright: ignore[reportSelfClsParameterName]
    def __getitem__(self, index: int | slice[int, int, int]) -> Self: ...
    def __dir__(self) -> list[str]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

# <plugins/bound/VideoNode>
# </plugins/bound/VideoNode>

# Behave like a Sequence
class AudioNode(RawNode):
    sample_type: Final[SampleType]
    bits_per_sample: Final[int]
    bytes_per_sample: Final[int]
    channel_layout: Final[int]
    num_channels: Final[int]
    sample_rate: Final[int]
    num_samples: Final[int]
    num_frames: Final[int]
    @overload  # type: ignore[override]
    def get_frame_async(self, n: int) -> Future[AudioFrame]: ...
    @overload
    def get_frame_async(self, n: int, cb: Callable[[AudioFrame | None, Exception | None], None]) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def frames(
        self, prefetch: int | None = None, backlog: int | None = None, close: bool = False
    ) -> Iterator[AudioFrame]: ...
    def __getattr__(self, name: str) -> Plugin: ...
    def get_frame(self, n: int) -> AudioFrame: ...
    def set_output(self, index: int = 0) -> None: ...
    @property
    def channels(self) -> ChannelLayout: ...
    def __add_(x, y: Self) -> Self: ...  # pyright: ignore[reportSelfClsParameterName]
    def __mul_(a, b: Self) -> Self: ...  # pyright: ignore[reportSelfClsParameterName]
    def __getitem__(self, index: int | slice[int, int, None | Literal[1]]) -> Self: ...
    def __dir__(self) -> list[str]: ...
    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

# <plugins/bound/AudioNode>
# </plugins/bound/AudioNode>

class Core:
    @property
    def num_threads(self) -> int: ...
    @num_threads.setter
    def num_threads(self, value: int) -> None: ...
    @property
    def max_cache_size(self) -> int: ...
    @max_cache_size.setter
    def max_cache_size(self, mb: int) -> None: ...
    @property
    def used_cache_size(self) -> int: ...
    @property
    def flags(self) -> int: ...
    def __getattr__(self, name: str) -> Plugin: ...
    def plugins(self) -> Iterator[Plugin]: ...
    def query_video_format(
        self,
        color_family: int,
        sample_type: int,
        bits_per_sample: int,
        subsampling_w: int = 0,
        subsampling_h: int = 0,
    ) -> VideoFormat: ...
    def get_video_format(self, id: _SupportsInt) -> VideoFormat: ...
    def create_video_frame(self, format: VideoFormat, width: int, height: int) -> VideoFrame: ...
    def log_message(self, message_type: int, message: str) -> None: ...
    def add_log_handler(self, handler_func: Callable[[MessageType, str], None]) -> LogHandle: ...
    def remove_log_handler(self, handle: LogHandle) -> None: ...
    def clear_cache(self) -> None: ...
    @property
    def core_version(self) -> VapourSynthVersion: ...
    @property
    def api_version(self) -> VapourSynthAPIVersion: ...
    @deprecated("core.version() is deprecated, use str(core)!", category=DeprecationWarning)
    def version(self) -> str: ...
    @deprecated(
        "core.version_number() is deprecated, use core.core_version.release_major!", category=DeprecationWarning
    )
    def version_number(self) -> int: ...
    def __dir__(self) -> list[str]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

# <plugins/bound/Core>
# </plugins/bound/Core>

# _CoreProxy doesn't inherit from Core but __getattr__ returns the attribute from the actual core
class _CoreProxy(Core):
    @property
    def core(self) -> Core: ...
    def __setattr__(self, name: str, value: Any) -> None: ...

core: _CoreProxy

# <plugins/implementations>
# </plugins/implementations>
